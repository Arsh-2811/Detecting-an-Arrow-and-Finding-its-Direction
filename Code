import cv2 as cv
import numpy as np  
import math      

def nothing():                 # definig a function that does nothing . very useful as if we have to use it a lot of times
    pass

font = cv.FONT_HERSHEY_COMPLEX        # Defining the font used in all purposes to be displayed on the frame

#cv.namedWindow('frame')            # Initialising a window names 'qwe' which will show all our trackbars

#cv.createTrackbar('LH', 'frame', 0, 180, nothing)         # Creating trackbars for defining the range of red colour in hsv hue
#cv.createTrackbar('LS', 'frame', 0, 255, nothing)
#cv.createTrackbar('LV', 'frame', 0, 255, nothing)
#cv.createTrackbar('RH', 'frame', 180, 180, nothing)
#cv.createTrackbar('RS', 'frame', 255, 255, nothing)
#cv.createTrackbar('RV', 'frame', 255, 255, nothing)
#cv.createTrackbar('EPSLN', 'qwe', 0, 100, nothing)      # Creating a trackbar for adjusting the epsilon value in the approvPolyDP function

capture = cv.VideoCapture(0)

                   
while True:    

    isTrue, frame = capture.read()

    #l_h = cv.getTrackbarPos('LH', 'frame')              # Using the trackbars that we created 
    #l_s = cv.getTrackbarPos('LS', 'frame')
    #l_v = cv.getTrackbarPos('LV', 'frame')
    #r_h = cv.getTrackbarPos('RH', 'frame')
    #r_s = cv.getTrackbarPos('RS', 'frame')
    #r_v = cv.getTrackbarPos('RV', 'frame') 
    #epsln = cv.getTrackbarPos('LOL', 'qwe')                                 

    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)         # Converting bgr image to hsc to extract out red colour

    #lower_red = np.array([l_h,  l_s, l_v])            # Finding the upper and lower limit using the trackbars that we created
    #upper_red = np.array([r_h, r_s, r_v])

    lower_red1 = np.array([0,  70, 50])                # Defining the lower range of red colour in hsv hue
    upper_red1 = np.array([10, 255, 255])              # Defining the upper range of red colour in hsv hue
  
    mask1 = cv.inRange(hsv, lower_red1, upper_red1)       # Masking the hsv frame according to the lower and upper values we defined above

    lower_red2 = np.array([170,  70, 50])                # Defining the lower range of red colour in hsv hue
    upper_red2 = np.array([180, 255, 255])              # Defining the upper range of red colour in hsv hue
  
    mask2 = cv.inRange(hsv, lower_red2, upper_red2)       # Masking the hsv frame according to the lower and upper values we defined above
    
    mask = mask1 + mask2

    kernel = np.ones((5,5), np.uint8)                  # numpy method to clear a black square of pixel 5 by 5
    mask = cv.erode(mask, kernel)                      # this is to remove noise further from the background

    #cv.imshow('Mask', mask)

    contours, hierarchy = cv.findContours(mask, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)           # Finding the contours in the mask

    for cnt in contours :                                                      # Iterating through Each contour

        area = cv.contourArea(cnt)                                             # Finding the area of ech contour       

        approx = cv.approxPolyDP(cnt, 0.03*cv.arcLength(cnt, True), True)    # True defines we are working with closed polygons   
        
        if area > 400 :                      # just to remove some more noise i.e. remove the countours which have area less than 400 pixels
        
            #cv.drawContours(frame, [approx], 0, (0, 0, 0), thickness=3)

            if len(approx) == 5 : 

                #let us believe to have 5 points pt1, pt2, pt3, pt4 and pt5
                
                pt1x = approx.ravel()[0]             # Defining the x and y coordinates of the point from the approxPolyDP function that we created above.
                pt1y = approx.ravel()[1]
                pt2x = approx.ravel()[2] 
                pt2y = approx.ravel()[3]
                pt3x = approx.ravel()[4] 
                pt3y = approx.ravel()[5]
                pt4x = approx.ravel()[6] 
                pt4y = approx.ravel()[7]
                pt5x = approx.ravel()[8] 
                pt5y = approx.ravel()[9]

                def getAngle(a, b, c):                 # Function to get angle between 0 and 360 degree between any 3 pointa
                    ang = math.degrees(math.atan2(c[1]-b[1], c[0]-b[0]) - math.atan2(a[1]-b[1], a[0]-b[0]))
                    return ang + 360 if ang < 0 else ang
                
                a123 = getAngle((pt1x, pt1y), (pt2x, pt2y), (pt3x, pt3y))
                a234 = getAngle((pt2x, pt2y), (pt3x, pt3y), (pt4x, pt4y))
                a345 = getAngle((pt3x, pt3y), (pt4x, pt4y), (pt5x, pt5y))
                a451 = getAngle((pt4x, pt4y), (pt5x, pt5y), (pt1x, pt1y))
                a512 = getAngle((pt5x, pt5y), (pt1x, pt1y), (pt2x, pt2y))

                list_of_pnts = [[pt1x, pt1y, pt2x, pt2y, pt3x, pt3y], [pt2x, pt2y, pt3x, pt3y, pt4x, pt4y], [pt3x, pt3y, pt4x, pt4y, pt5x, pt5y], [pt4x, pt4y, pt5x, pt5y, pt1x, pt1y], [pt5x, pt5y, pt1x, pt1y, pt2x, pt2y]]
 
                list_of_angles= [a123, a234, a345, a451, a512]

                print(list_of_angles)

                print(a123)
                print(a234)
                print(a345)
                print(a451)
                print(a512)

                req_angle = []

                for i in range(len(list_of_angles)):         # Iterating through the angles we found to find the only accute angle
                    if list_of_angles[i] <  80 :
                        req_angle.append(list_of_angles[i])

                print(req_angle)
                
                if len(req_angle) == 1 :
                
                    q = req_angle[0]
                
                    p = list_of_angles.index(q)

                    tpr = list_of_pnts[p]

                    point_a = int((tpr[0] + tpr[4])/2), int((tpr[1] + tpr[5])/2)
                    point_b = int(tpr[2]), int(tpr[3])

                    #cv.putText(frame, "Reading Angle", (x, y), font, 0.5, (255, 0, 0))
                    
                    frame = cv.arrowedLine(frame, point_a, point_b, (255, 0, 255), thickness=2)        # Just for testing purpose

                    angle = math.atan((((tpr[1] + tpr[5])/2) - (tpr[3])) / (((tpr[0] + tpr[4])/2) - (tpr[2])))* 180 / math.pi

                    pointa_b_x = ((tpr[0] + tpr[4])/2) - (tpr[2])               # Point a relative to point b - x cordinate
                    pointa_b_y = ((tpr[1] + tpr[5])/2) - (tpr[3])               # Point a relative to point b - y coordinate

                    #cv.putText(frame, 'x coordinate isa ' + str(pointa_b_x), (80, 80), font, 0.5, (0, 255, 0)) 
                    #cv.putText(frame, 'y coordinate is' + str(pointa_b_y), (40, 40), font, 0.5, (0, 255, 0)) 

                    if pointa_b_x > 0 and pointa_b_y > 0 : 
                        angle_f = angle

                    if pointa_b_x < 0 and pointa_b_y > 0 :
                        angle_f = angle + 180

                    if pointa_b_x < 0 and pointa_b_y < 0 :
                        angle_f = angle + 180

                    if pointa_b_x > 0 and pointa_b_y < 0 :
                        angle_f =  angle + 360                     

                    cv.putText(frame, str(int(angle_f)), (60, 60), font, 2, (0, 69, 255))  

    cv.imshow('Frame', frame)            

    if cv.waitKey(20) & 0xFF==ord('d'):            # Way to break the infinite loop by pressing 'd' on the keyboard .    
        break 

capture.release()                               
cv.destroyAllWindows()
